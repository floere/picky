<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type' />
    <meta content='EN' http-equiv='Content-Language' />
    <meta content='Florian Hanke, florianhanke.com' name='author' />
    <meta content='picky, ruby, single field, semantic small text, search engine, light, lightweight' name='keywords' />
    <meta content='Picky: The fast and easy to configure Ruby search engine' name='abstract' />
    <meta content='Picky: The fast and easy to configure Ruby search engine. Offers a server, a client, and a statistics interface.' name='description' />
    <meta content='index, follow' name='robots' />
    <meta content='3 days' name='revisit-after' />
    <link href='favicon.ico' rel='shortcut icon' />
    <link href='stylesheets/basic.css' rel='stylesheet' type='text/css' />
    <link href='stylesheets/specific.css' rel='stylesheet' type='text/css' />
    <link href='stylesheets/grid.css' rel='stylesheet' type='text/css' />
    <link href='stylesheets/colors.css' rel='stylesheet' type='text/css' />
    <script src='javascripts/sh.min.js' type='text/javascript'></script>
    <script src='javascripts/sh-ruby.min.js' type='text/javascript'></script>
    <script type="text/javascript" src="https://apis.google.com/js/plusone.js"></script>
    <script type="text/javascript">function plusone_vote(obj){_gaq.push(['_trackEvent','plusone',obj.state]);}</script>
    <title>
      Picky:
      Documentation
    </title>
    <script type='text/javascript'>
      //<![CDATA[
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-20991642-1']);
        _gaq.push(['_trackPageview']);
        
        (function() {
          var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
          ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      //]]>
    </script>
  </head>
  <body onload='sh_highlightDocument();'>
    <div class='header'>
      <a href='http://github.com/floere/picky'>
        <img alt='Fork me on GitHub' src='images/forkme.png' style='position: fixed; top: -10px; right: -10px; border: 0; z-index: 1;' />
      </a>
    </div>
    <div class='picky' title='Happy Picky (drawn on iPhone)'></div>
    <div class='container_2'>
      <h1>Picky</h1>
      <div class='navigation'>
        <a class='' href='index.html'>about</a>
        <a class='' href='details.html'>semantic text?</a>
        <a class='' href='getting_started.html'>get started</a>
        <a class='' href='features.html'>features</a>
        <a class='right' href='enterprise.html'>enterprise?</a>
        <a class='right' href='status.html'>status/contributions</a>
        <a class='right' href='videos.html'>videos</a>
        <a class='current right' href='documentation.html'>docs</a>
      </div>
    </div>
    <div class='container_2'>
      <h2>
        Documentation
        <div class='social'>
          <a class='twitter-follow-button' data-show-count='false' data-width='110px' href='https://twitter.com/hanke'>Follow @hanke</a>
          <a class='twitter-follow-button' data-show-count='false' data-width='123px' href='https://twitter.com/picky_rb'>Follow @picky_rb</a>
          <a class='twitter-share-button' data-count='none' data-text='Picky: The fast Ruby semantic search engine' data-url='http://florianhanke.com/picky/' data-via='hanke' data-width='55px' href='http://twitter.com/share'>Tweet</a>
          <div callback='plusone_vote' class='g-plusone' data-href='http://florianhanke.com/picky/' data-size='medium' data-width='60'></div>
          <script src='http://platform.twitter.com/widgets.js' type='text/javascript'></script>
        </div>
      </h2>
    </div>
    <div class="container_2">
<div class="grid_1">
<h3><span class="caps">API</span> Docs</h3>
<p>For documentation on how to configure Picky, see</p>
<p><a href="doc/server/index.html">Server <span class="caps">API</span> docs</a> and <a href="doc/client/index.html">Client <span class="caps">API</span> docs</a></p>
<p>and for a bit more info <a href="http://github.com/floere/picky/wiki">the Wiki</a> in the <a href="http://github.com/floere/picky">repository</a>.</p>
</div>
<div class="grid_1">
<h3>Help?</h3>
<p>If neither the docs, nor the Wiki, nor the single page help has helped, feel free to contact us <a href="index.html">through the methods described on the about page</a>.</p>
<p>Best of success!</p>
</div>
</div>
<div class="container_2">
<h2>Single Page Help</h2>
<div class="grid_2 white">
<div class="tags">Note: Some headers have tags like &#8220;performance&#8221;, so you can use your browser search to search for them.</div>
<div class="index">
<ol>
	<li><a href="#allruby">All Ruby</a></li>
	<li><a href="#transparency">Transparency</a></li>
	<li><a href="#generators">Generators</a>
	<ol>
		<li><a href="#generators-servers">Servers</a>
		<ol>
			<li><a href="#generators-servers-sinatra">Sinatra</a></li>
			<li><a href="#generators-servers-classic">Classic</a></li>
			<li><a href="#generators-servers-allinone">All In One</a></li>
		</ol></li>
		<li><a href="#generators-clients">Clients</a>
		<ol>
			<li><a href="#generators-clients-sinatra">Sinatra</a></li>
		</ol></li>
	</ol></li>
	<li><a href="#servers">Servers / Applications</a>
	<ol>
		<li><a href="#servers-classicvssinatra">Classic vs. Sinatra Style</a></li>
		<li><a href="#servers-sinatra">Sinatra Style</a>
		<ol>
			<li><a href="#servers-sinatra-routing">Routing</a></li>
			<li><a href="#servers-sinatra-logging">Logging</a></li>
		</ol></li>
		<li><a href="#servers-classic">Classic Style</a>
		<ol>
			<li><a href="#servers-classic-routing">Routing</a></li>
			<li><a href="#servers-classic-logging">Logging</a></li>
		</ol></li>
		<li><a href="#servers-allinone" title="Client + Server">All In One</a></li>
	</ol></li>
	<li><a href="#indexes">Indexes</a>
	<ol>
		<li><a href="#indexes-types">Types</a>
		<ol>
			<li><a href="#indexes-types-memory">In-Memory / File-based</a></li>
			<li><a href="#indexes-types-redis">Redis</a></li>
		</ol></li>
		<li><a href="#indexes-acessing">Accessing</a></li>
		<li><a href="#indexes-configuration">Configuration</a></li>
		<li><a href="#indexes-sources">Data Sources</a>
		<ol>
			<li><a href="#indexes-sources-each">Responding to #each</a></li>
			<li><a href="#indexes-sources-delayed">Delayed</a></li>
			<li><a href="#indexes-sources-classic">Classic Style</a></li>
		</ol></li>
		<li><a href="#indexes-indexing">Indexing / Tokenizing</a></li>
		<li><a href="#indexes-categories">Categories</a>
		<ol>
			<li><a href="#indexes-categories-partial">Option partial</a></li>
			<li><a href="#indexes-categories-weights">Option weights</a></li>
			<li><a href="#indexes-categories-similarity">Option similarity</a></li>
			<li><a href="#indexes-categories-qualifiers" title="categorizing">Option qualifier / qualifiers</a></li>
			<li><a href="#indexes-categories-from">Option from</a></li>
			<li><a href="#indexes-categories-keyformat">Option key_format</a></li>
			<li><a href="#indexes-categories-source">Option source</a></li>
			<li><a href="#indexes-categories-searching">Searching</a></li>
		</ol></li>
		<li><a href="#indexes-keyformat" title="Format of the indexed Ids">Key Format</a></li>
		<li><a href="#indexes-results">Identifying in Results</a></li>
		<li><a href="#indexes-indexing">Indexing</a></li>
		<li><a href="#indexes-reloading">Reloading</a>
		<ol>
			<li><a href="#indexes-reloading-signals">Using signals</a></li>
		</ol></li>
		<li><a href="#indexes-reindexing">Reindex</a></li>
	</ol></li>
	<li><a href="#search">Search</a>
	<ol>
		<li><a href="#search-options">Options</a>
		<ol>
			<li><a href="#search-options-searching">Searching / Tokenizing</a></li>
			<li><a href="#search-options-boost">Boost</a></li>
			<li><a href="#search-options-ignore">Ignore Categories</a></li>
			<li><a href="#search-options-unassigned">Ignore Unassigned Tokens</a></li>
			<li><a href="#search-options-maxallocations">Maximum Allocations</a></li>
			<li><a href="#search-options-terminateearly">Early Termination</a></li>
		</ol></li>
	</ol></li>
	<li><a href="#results">Results</a>
	<ol>
		<li><a href="#results-logging">Logging</a></li>
		<li><a href="#results-sorting">Sorting</a><br />
</div></li>
	</ol></li>
</ol>
<h2 id="allruby">All Ruby</h2>
<p>Never forget this: <strong>Picky is all Ruby, all the time</strong>!</p>
<p>Even though we only describe examples of classic and Sinatra style servers, Picky can be included directly in Rails, as a client or server. Or in DRb. Or in your simple script without <span class="caps">HTTP</span>. Anywhere you like, as long as it&#8217;s Ruby, really.</p>
<h2 id="transparency">Transparency</h2>
<p>Picky tries its best to be <strong>transparent</strong> so you can go have a look if something goes wrong. It wants you to <strong>never feel powerless</strong>.</p>
<p>All the indexes can be viewed in the <code>/index</code> directory of the project. They are waiting for you to inspect their JSONy goodness.<br />
Should anything not work with your search, you can see how it is indexed in the actual indexes and change your indexing parameters accordingly.</p>
<p>Since all is Ruby, you can log as much data as you want to help you improve your search application until it&#8217;s working perfectly.</p>
<h2 id="generators">Generators</h2>
<p>Picky offers a few generators to have a running server and client up in 5 minutes. Please follow the <a href="getting_started.html">Getting Started</a>.</p>
<p>Or, run gem install</p>
<pre><code>gem install picky-generators</code></pre>
<p>and simply enter</p>
<pre><code>picky generate</code></pre>
<p>This will raise an <code>Picky::Generators::NotFoundException</code> and show you the possibilities.</p>
<p>The &#8220;All In One&#8221; Client/Server is interested for Heroku projects, as it is a bit complicated to set up two servers that interact with each other.</p>
<h3 id="generators-servers">Servers</h3>
<p>Currently, Picky offers three generated example servers that you can adapt to your project: <strong>Sinatra</strong> (the default), <strong>Classic</strong> and <strong>All In One</strong>.</p>
<h4 id="generators-servers-sinatra">Sinatra</h4>
<p>This server is generated with</p>
<pre><code>picky generate sinatra_server target_directory</code></pre>
<p>and generates a full sinatra server that you can try immediately. Just follow the instructions.</p>
<h4 id="generators-servers-classic">Classic</h4>
<p>This server is generated with</p>
<pre><code>picky generate classic_server target_directory</code></pre>
<p>and generates a full classic Picky server that you can try immediately. Just follow the instructions.</p>
<h4 id="generators-servers-allinone">All In One</h4>
<p>All In One is actually a single Sinatra server containing the Server <span class="caps">AND</span> the client. This server is generated with</p>
<pre><code>picky generate all_in_one target_directory</code></pre>
<p>and generates a full Sinatra Picky server and client that you can try immediately. Just follow the instructions.</p>
<h3 id="generators-clients">Clients</h3>
<p>Picky currently offers an example <code>Sinatra</code> client that you can adapt for your project (or look at it how to use in Rails).</p>
<h4 id="generators-clients-sinatra">Sinatra</h4>
<p>This client is generated with</p>
<pre><code>picky generate sinatra_client target_directory</code></pre>
<p>and generates a full Sinatra client (including Javascript etc.) that you can try immediately. Just follow the instructions.</p>
<h2 id="servers">Servers / Applications</h2>
<p>Picky, from version 3.0 onwards, is designed to run <strong>anywhere</strong>, <strong>in anything</strong>.</p>
<p>This means you can have a Picky server running in a DRb instance if you want to. Or in irb, for example.</p>
<p>We do run and test the Picky server in two styles, <a href="#servers-classicvssinatra">Classic and Sinatra</a>.</p>
<p>But don&#8217;t let that stop you from just using it in a class or just a script. This is a perfectly ok way to use Picky:</p>
<pre><code>
require 'picky'

include Picky # So we don't have to type Picky:: everywhere.

books_index = Index.new(:books) do
  source Sources::CSV.new(:title, :author, file: 'library.csv')
  category :title
  category :author
end

books_index.index
books_index.reload

books = Search.new books_index do
  boost [:title, :author] =&gt; +2
end

results = books.search "test"
results = books.search "alan turing"

require 'pp'
pp results.to_hash
</code></pre>
<p>More <strong>Ruby</strong>, more <strong>power</strong> to you!</p>
<h3 id="servers-classicvssinatra">Classic vs. Sinatra Style</h3>
<p>Picky currently offers two tested server styles, &#8220;Classic&#8221; and &#8220;Sinatra&#8221;. They differ as follows:</p>
<table>
	<tr>
		<td>                  </td>
		<td> Classic                                        </td>
		<td> Sinatra           </td>
	</tr>
	<tr>
		<td> application file </td>
		<td> <code>app/application.rb</code>                           </td>
		<td> <code>app.rb</code>          </td>
	</tr>
	<tr>
		<td> routing          </td>
		<td> Use <code>route</code> method (uses the <code>rack-mount</code> gem) </td>
		<td> Use <code>get</code> method </td>
	</tr>
	<tr>
		<td> rake tasks       </td>
		<td> All working                                    </td>
		<td> routes missing </td>
	</tr>
</table>
<p>Classic is also a bit more pedal-to-the-metal style, thus a bit faster.</p>
<p>However, we recommend to use the Sinatra style. It is <a href="http://www.sinatrarb.com/intro">very well documented</a> very customizable and Picky and Sinatra share the same core value, namely that it is all relatively simple Ruby, and can thus be changed and adapted to your needs, while still remaining easily readable.</p>
<h3 id="servers-sinatra">Sinatra Style</h3>
<p>A <a href="http://sinatrarb.com">Sinatra</a> server is usually just a single file. In Picky, it is a top-level file named</p>
<pre><code>app.rb</code></pre>
<p>We recommend to use the <a href="http://www.sinatrarb.com/intro#Serving%20a%20Modular%20Application">modular Sinatra style</a> as opposed to the <a href="http://www.sinatrarb.com/intro#Using%20a%20Classic%20Style%20Application%20with%20a%20config.ru">classic style</a>. It&#8217;s possible to write a Picky server in the classic style, but using the modular style offers more options.</p>
<pre><code>
require 'sinatra/base'
require 'picky'

class BookSearch &lt; Sinatra::Application

  books_index = Index.new(:books) do
    source { Book.order("isbn ASC") }
    category :title
    category :author
  end

  books = Search.new books_index do
    boost [:title, :author] =&gt; +2
  end

  get '/books' do
    results = books.search params[:query],
                           params[:ids]    || 20,
                           params[:offset] ||  0
    results.to_json
  end

end
</code></pre>
<p>This is already a complete Sinatra server.</p>
<h4 id="servers-sinatra-routing">Routing</h4>
<p>The Sinatra Picky server uses the same routing as Sinatra (of course). <a href="http://www.sinatrarb.com/intro#Routes">More information on Sinara routing</a>.</p>
<p>If you use the server with the picky client software (provided with the picky-client gem), you should return <span class="caps">JSON</span> from the Sinatra <code>get</code>.<br />
Just call <code>to_json</code> on the returned results to get the results in <span class="caps">JSON</span> format.</p>
<pre><code>
get '/books' do
  results = books.search params[:query], params[:ids] || 20, params[:offset] ||  0
  results.to_json
end
</code></pre>
<p>The above example search can be called using for example <code>curl</code>:</p>
<pre><code>curl 'localhost:8080/books?query=test'</code></pre>
<h4 id="servers-sinatra-logging">Logging</h4>
<p>This is one way to do it:</p>
<pre><code>
MyLogger = Logger.new "log/search.log"

# ...

get '/books' do
  results = books.search "test"
  MyLogger.info results
  results.to_json
end
</code></pre>
<p>or set it up in separate files for different environments:</p>
<pre><code>
require "logging/#{PICKY_ENVIRONMENT}"
</code></pre>
<p>Note that this is not Rack logging, but Picky search engine logging. The resulting file can be used with the picky-statistics gem.</p>
<h3 id="servers-classic">Classic Style</h3>
<p>Classic Style is the pre 3.0 way of doing things, but still perfectly fine.</p>
<p>A Classic server is usually just a single file. It is a file named</p>
<pre><code>app/application.rb</code></pre>
<p>It is very similar to the Sinatra way of doing things:</p>
<pre><code>
require 'picky'

class BookSearch &lt; Picky::Application

  # So we don't have to write Picky::
  # in front of everything.
  #
  include Picky

  books_index = Index.new :books do
    source   Sources::CSV.new(:title, :author, file: "data/#{PICKY_ENVIRONMENT}/library.csv")
    indexing splits_text_on: /[\s,]/
    category :title
    category :author
  end

  books = Search.new books_index do
    searching splits_text_on: /[\s,]/
    boost [:title, :author] =&gt; +2
  end

  route %r{\A/books\Z} =&gt; books

end
</code></pre>
<p>The main difference is the routing for which the gem <code>rack-mount</code> is used (the same Rails uses).</p>
<h4 id="servers-classic-routing">Routing</h4>
<p>Routing is done using the <code>#route</code> method.</p>
<p>Some examples:</p>
<pre><code>
  route %r{/books} =&gt; book_search,
        %r{/dvds}  =&gt; dvd_search

  route %r{/mp3s}  =&gt; mp3_search
</code></pre>
<h4 id="servers-classic-logging">Logging</h4>
<p>A Picky classic server logs to the logger defined with the <code>Picky.logger=</code> writer.</p>
<p>Set it up in a separate <code>logging.rb</code> file (or directly in the <code>app/application.rb</code> file).</p>
<pre><code>
  Picky.logger = Logger.new("log/search.log")
</code></pre>
<p>and the Picky classic server will log the results into it, if it is defined.</p>
<p>Why in a separate file? So that you can have different logging for different environments.</p>
<p>More power to you.</p>
<h3 id="servers-allinone">All In One (Client + Server)</h3>
<p>The All In One server is a Sinatra server and a Sinatra client rolled in one.</p>
<p>It&#8217;s best to just generate one and look at it:</p>
<pre><code>picky generate all_in_one all_in_one_test</code></pre>
<p>and then follow the instructions.</p>
<p>When would you use an All In One server? One place might be <a href="http://heroku.com">Heroku</a>, since it is a bit more complicated to set up two servers that interact with each other.</p>
<p>It&#8217;s nice for small convenient searches. For productive setups we recommend to use a separate server to make everything separately cacheable etc.</p>
<h2 id="indexes">Indexes</h2>
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>
<h3 id="indexes-types">Types</h3>
<p>Picky offers a choice of two index types, &#8220;In-Memory&#8221; and &#8220;Redis&#8221;. The former saves its indexes on disk and reloads them into memory and the latter saves its indexes in Redis.</p>
<p>This is how they look in code:</p>
<pre><code>
books_memory_index = Index.new(:books) do
  # Configuration goes here.
end

books_redis_index = Index.new(:books) do
  backend Backends::Redis.new
  # Configuration goes here.
end
</code></pre>
<p>Both save the preprocessed data from the data source in the <code>/index</code> directory so you can go look if the data is preprocessed correctly.</p>
<p>Indexes then can be used with a <code>Search</code> interface.</p>
<p>Searching over one index:</p>
<pre><code>
books = Search.new books_index
</code></pre>
<p>Searching over multiple indexes:</p>
<pre><code>
media = Search.new books_index, dvd_index, mp3_index
</code></pre>
<h4 id="indexes-types-memory">In-Memory / File-based</h4>
<p>The in-memory index saves its indexes as files transparently in the form of <span class="caps">JSON</span> files that reside in the <code>/index</code> directory.</p>
<p>When the server is started, they are loaded into memory. As soon as the server is stopped, the indexes are not in memory again.</p>
<p>Indexing regenerates the <span class="caps">JSON</span> index files and can be reloaded into memory, even in the running server (see below).</p>
<h4 id="indexes-types-redis">Redis</h4>
<p>The Redis index saves its indexes in the Redis server on the default port, using database 15.</p>
<p>When the server is started, it connects to the Redis server and uses the indexes in the key-value store.</p>
<p>Indexing regenerates the indexes in the Redis server – you do not have to restart the server for that.</p>
<h3 id="indexes-acessing">Accessing</h3>
<p>If you don&#8217;t have access to your indexes directly, like so</p>
<pre><code>
books_index = Index.new(:books) do
  # ...
end

books_index.do_something_with_the_index
</code></pre>
<p>and for example you&#8217;d like to access the index from a rake task, you can use</p>
<pre><code>Picky::Indexes</code></pre>
<p>to get <strong>all indexes</strong>.</p>
<p>To get a <strong>single index</strong> use</p>
<pre><code>Picky::Indexes[:index_name]</code></pre>
<p>and to get a <strong>single category</strong>, use</p>
<pre><code>Picky::Indexes[:index_name][:category_name]</code></pre>
<p>That&#8217;s it.</p>
<h3 id="indexes-configuration">Configuration</h3>
<p>This is all you can do to configure an index:</p>
<pre><code>
books_index = Index.new :books do
  source   { Book.order("isbn ASC") }

  indexing removes_characters:                 /[^a-zA-Z0-9\s\:\"\&amp;\.\|]/i,                   # Default: nil
           stopwords:                          /\b(and|the|or|on|of|in)\b/i,                  # Default: nil
           splits_text_on:                     /[\s\/\-\_\:\"\&amp;\/]/,                          # Default: /\s/
           removes_characters_after_splitting: /[\.]/,                                        # Default: nil
           normalizes_words:                   [[/\$(\w+)/i, '\1 dollars']],                  # Default: nil
           rejects_token_if:                   lambda { |token| token == :blurf },            # Default: nil
           case_sensitive:                     true,                                          # Default: false
           substitutes_characters_with:        Picky::CharacterSubstituters::WestEuropean.new # Default: nil

  category :id
  category :title,
           partial:    Partial::Substring.new(:from =&gt; 1),
           similarity: Similarity::DoubleMetaphone.new(2),
           qualifiers: [:t, :title, :titre]
  category :author,
           partial: Partial::Substring.new(:from =&gt; -2)
  category :year,
           partial: Partial::None.new
           qualifiers: [:y, :year, :annee]

  result_identifier 'boooookies'
end
</code></pre>
<p>Usually you don&#8217;t need to configure all that.</p>
<p>But if your boss comes in the door and asks why X is not found… you know. And you can improve the search engine relatively <strong>quickly and painless</strong>.</p>
<p>More power to you.</p>
<h3 id="indexes-sources">Data Sources</h3>
<p>Data sources define where the data for an index comes from.</p>
<p>You define them on an <strong>index</strong>:</p>
<pre><code>
Index.new :books do
  source some_data_source
end
</code></pre>
<p>Or even a <strong>single category</strong>:</p>
<pre><code>
Index.new :books do
  source some_data_source
  category :title,
           source: some_data_source
end
</code></pre>
<p>At the moment there are two possibilities: <a href="#indexes-sources-each">Objects responding to #each</a> and <a href="#indexes-sources-classic">Picky classic style sources</a>.</p>
<p>See more about them <a href="http://github.com/floere/picky/wiki/Sources-Configuration">in the Wiki</a>.</p>
<h4 id="indexes-sources-each">Responding to #each</h4>
<p>Picky supports any data source as long as it supports <code>#each</code>.</p>
<p>See <a href="http://florianhanke.com/blog/2011/04/14/picky-two-point-two-point-oh.html">under Flexible Sources</a> how you can use this.</p>
<p>In short. Model:</p>
<pre><code>
class Monkey
  attr_reader :id, :name, :color
  def initialize id, name, color
    @id, @name, @color = id, name, color
  end
end
</code></pre>
<p>The data:</p>
<pre><code>
monkeys = [
  Monkey.new(1, 'pete', 'red'),
  Monkey.new(2, 'joey', 'green'),
  Monkey.new(3, 'hans', 'blue')
]
</code></pre>
<p>Setting the array it as a source</p>
<pre><code>
Index::Memory.new :monkeys do
  source   monkeys
  category :name
  category :couleur, :from =&gt; :color # The couleur category will take its data from the #color method.
end
</code></pre>
<h4 id="indexes-sources-delayed">Delayed</h4>
<p>If you define the source directly in the index block, it will be evaluated instantly:</p>
<pre><code>
Index::Memory.new :books do
  source Book.order('title ASC')
end
</code></pre>
<p>This works with ActiveRecord and other similar ORMs since <code>Book.order</code> returns a proxy object that will only be evaluated when the server is indexing.</p>
<p>For example, this would instantly get the records, since <code>#all</code> is a kicker method:</p>
<pre><code>
Index::Memory.new :books do
  source Book.all # Not the best idea.
end
</code></pre>
<p>In this case, you can give the <code>source</code> method a block:</p>
<pre><code>
Index::Memory.new :books do
  source { Book.all }
end
</code></pre>
<p>This block will be executed as soon as the indexing is running, but not earlier.</p>
<h4 id="indexes-sources-classic">Classic Style</h4>
<p>The classic style uses Picky <code>Sources</code> to load the data into the index.</p>
<pre><code>
Index.new :books do
  source Sources::CSV.new(:title, :author, file: 'app/library.csv')
end
</code></pre>
<p>Use this one if you want to use a simple <span class="caps">CSV</span> file.</p>
<p>However, you could also use the built-in Ruby <code>CSV</code> class and use it as an <code>#each</code> source (see above).</p>
<pre><code>
Index.new :books do
  source Sources::DB.new('SELECT id, title, author, isbn13 as isbn FROM books', file: 'app/db.yml')
end
</code></pre>
<p>Use this one if you want to use a database source with very custom <span class="caps">SQL</span> statements. If not, we suggest you use an <span class="caps">ORM</span> as an <code>#each</code> source (see above).</p>
<h3 id="indexes-indexing">Indexing / Tokenizing</h3>
<p>The <code>indexing</code> option describes how <strong>text data from the data source</strong> is handled.</p>
<p>Picky by default goes through the following list, in order:</p>
<ol>
	<li><strong>substitutes_characters_with</strong>: A character substituter that responds to <code>#substitute(text) #=&gt; substituted text</code></li>
	<li><strong>removes_characters</strong>: Regexp of characters to remove.</li>
	<li><strong>stopwords</strong>: Regexp of stopwords to remove.</li>
	<li><strong>splits_text_on</strong>: Regexp on where to split the data text.</li>
	<li><strong>removes_characters_after_splitting</strong>: Regexp on which characters to remove after the splitting.</li>
	<li><strong>normalizes_words</strong>: [[/matching_regexp/, &#8216;replace match \1&#8217;]]</li>
	<li><strong>rejects_token_if</strong>: lambda { |gets_token| gets_token == :hello }</li>
	<li><strong>case_sensitive</strong>: true or false, false is default.</li>
</ol>
<p>You pass the above options into</p>
<pre><code>
Index.new :books do
  indexing options_hash
end
</code></pre>
<p>Or, if you want it to be valid for <strong>all</strong> indexes, you can define it outside of the index definition:</p>
<pre><code>
indexing options_hash

Index.new :books do
  # ...
end
</code></pre>
<p>This only works in the sinatra server if you extend the Sinatra app with <code>Picky::Sinatra</code>, like so:</p>
<pre><code>
class MySearch &lt; Sinatra::Application

  extend Picky::Sinatra

  indexing options_hash

  # ...

end
</code></pre>
<p>You can provide your own tokenizer:</p>
<pre><code>
Index.new :books do
  indexing MyTokenizer.new
end
</code></pre>
<p>The tokenizer needs to respond to the method <code>#tokenize(text)</code>, returning an array of symbols, e.g. <code>[:my, :nice, :tokens]</code>. That&#8217;s it.</p>
<p>It should be rather performance efficient if you want your search engine to be fast.</p>
<p>Note that you can always take a look at the files in <code>/index</code> to see if everything is index tokenized correctly.</p>
<p>Also, <code>rake 'try[text,some_index,some_category]'</code> (<code>some_index</code>, <code>some_category</code> optional) tells you how a given text is indexed.</p>
<h3 id="indexes-categories">Categories</h3>
<p>Categories – usually what other search engines call fields – define <strong>categorized data</strong>. For example, book data might have a <code>title</code>, an <code>author</code> and an <code>isbn</code>.</p>
<p>So you define that:</p>
<pre><code>
Index.new :books do
  source { Book.order('author DESC') }

  category :title
  category :author
  category :isbn
end
</code></pre>
<p>(The example assumes that a <code>Book</code> has readers for <code>title</code>, <code>author</code>, and <code>isbn</code>)</p>
<p>This already works and a search will return categorized results. For example, a search for &#8220;Alan Tur&#8221; might categorize both words as <code>author</code>, but it might also at the same time categorize both as <code>title</code>. Or one as <code>title</code> and the other as <code>author</code>.</p>
<p>That&#8217;s a great starting point. So how can I customize the categories?</p>
<h4 id="indexes-categories-partial">Option partial</h4>
<p>The partial option defines if a word is also found when it is only <strong>partially entered</strong>. So, &#8220;Picky&#8221; might be already found when typing &#8220;Pic&#8221;.</p>
<p>You define this by this:</p>
<pre><code>
category :some, partial: Partial::Substring.new(from: -3)
</code></pre>
<p>(This is also the default)<br />
The option <code>from: 1</code> will make a word completely partially findable.</p>
<p>If you don&#8217;t want any partial finds to occur, use:</p>
<pre><code>
category :some, partial: Partial::None.new
</code></pre>
<p>You can also pass in your own partial generators. See <a href="http://florianhanke.com/blog/2011/08/15/picky-30-its-all-ruby-part-1.html">this article</a> to learn more.</p>
<h4 id="indexes-categories-weights">Option weights</h4>
<p>The weights option defines how strongly a word is weighed. By default, Picky rates a word according to the logarithm of its occurrence. This means that a word that occurs more often will be slightly higher weighed.</p>
<p>You define this by this:</p>
<pre><code>
category :some, weights: MyWeights.new
</code></pre>
<p>The default is <code>Weights::Logarithmic.new</code>.</p>
<p>You can also pass in your own weights generators. See <a href="http://florianhanke.com/blog/2011/08/15/picky-30-its-all-ruby-part-1.html">this article</a> to learn more.</p>
<p>If you don&#8217;t want Picky to calculate weights for your indexed entries, you can use constant or dynamic weights.</p>
<p>With 0.0 as default weight:</p>
<pre><code>
category :some, weights: Weights::Constant.new # Returns 0.0 for all results.
</code></pre>
<p>With 3.14 as set weight:</p>
<pre><code>
category :some, weights: Weights::Constant.new(3.14) # Returns 3.14 for all results.
</code></pre>
<p>Or with a dynamically calculated weight:</p>
<pre><code>
  Weights::Dynamic.new do |str_or_sym|
    sym_or_str.length # Uses the length of the symbol as weight.
  end
</code></pre>
<p>You almost never need to use your specific weights. More often than not, you can fiddle with boosting combinations of categories, via the <code>boost</code> method in searches.</p>
<h4 id="indexes-categories-similarity">Option similarity</h4>
<p>The similarity option defines if a word is also found when it is typed wrong, or <em>close</em> to another word. So, &#8220;Picky&#8221; might be already found when typing &#8220;Pocky~&#8221;. (Picky will search for similar word when you use the tilde, ~)</p>
<p>You define this by this:</p>
<pre><code>
category :some, similarity: Similarity::None.new
</code></pre>
<p>(This is also the default)</p>
<p>There are several built-in similarity options, like</p>
<pre><code>
category :some, similarity: Similarity::Soundex.new
category :this, similarity: Similarity::Metaphone.new
category :that, similarity: Similarity::DoubleMetaphone.new
</code></pre>
<p>You can also pass in your own similarity generators. See <a href="http://florianhanke.com/blog/2011/08/15/picky-30-its-all-ruby-part-1.html">this article</a> to learn more.</p>
<h4 id="indexes-categories-qualifiers">Option qualifier/qualifiers (categorizing)</h4>
<p>Usually, when you search for <code>"title:wizard"</code> you will only find books with &#8220;wizard&#8221; in their title.</p>
<p>Maybe your client would like to be able to only enter &#8220;t:wizard&#8221;. In that case you would use this option:</p>
<pre><code>
category :some,
         :qualifier =&gt; :t
</code></pre>
<p>Or if you&#8217;d like more to match:</p>
<pre><code>
category :some,
         qualifiers: [:t, :title, :titulo]
</code></pre>
<p>(This matches &#8220;t&#8221;, &#8220;title&#8221;, and also the italian &#8220;titulo&#8221;)</p>
<p>Picky will warn you if on one index the qualifiers are ambiguous (Picky will assume that the last &#8220;t&#8221; for example is the one you want to use).</p>
<p>This means that:</p>
<pre><code>
category :some,  :qualifier =&gt; :t
category :other, :qualifier =&gt; :t
</code></pre>
<p>Picky will assume that if you enter &#8220;t:bla&#8221;, you want to search in the :other category.</p>
<p>Searching in multiple categories can also be done. If you have:</p>
<pre><code>
category :some,  :qualifier =&gt; :s
category :other, :qualifier =&gt; :o
</code></pre>
<p>Then searching with &#8220;s,o:bla&#8221; will search for bla in both <code>:some</code> and <code>:other</code>. Neat, eh?</p>
<h4 id="indexes-categories-from">Option from</h4>
<p>Usually, the categories will take their data from the reader or field that is the same as their name.</p>
<p>Sometimes though, the model has not the right names. Say, you have an italian book model, <code>Libro</code>. But you still want to use english category names.</p>
<pre><code>
Index.new :books do
  source { Libro.order('autore DESC') }

  category :title,  :from =&gt; :titulo
  category :author, :from =&gt; :autore
  category :isbn
end
</code></pre>
<h4 id="indexes-categories-keyformat">Option key_format</h4>
<p>You almost never use this, as the key format will usually be the same for all categories, which is when you would define it on the index, <a href="#indexes-keyformat">like so</a>.</p>
<p>But if you need to, use as with the index.</p>
<pre><code>
Index.new :books do
  category :title,
           :key_format =&gt; :to_sym
end
</code></pre>
<h4 id="indexes-categories-source">Option source</h4>
<p>You almost never use this, as the source will usually be the same for all categories, which is when you would define it on the index, <a href="#indexes-sources">like so</a>.</p>
<p>But if you need to, use as with the index.</p>
<pre><code>
Index.new :books do
  category :title,
           source: some_source
end
</code></pre>
<h4 id="indexes-categories-searching">Searching</h4>
<p>Searching offers a few options. They are:</p>
<ul>
	<li>Partial: <code>something*</code> (By default, the last word is implicitly partial)</li>
	<li>Non-Partial: <code>"something"</code> (The quotes make the query on this word explicitly non-partial)</li>
	<li>Similarity: <code>something~</code> (The tilde makes this word eligible for similarity search)</li>
	<li>Categorized: <code>title:something</code> (Picky will only search in the category designated as title, in each index of the search)</li>
	<li>Multi-categorized: <code>title,author:something</code> (Picky will search in title and author categories, in each index of the search)</li>
</ul>
<p>These options can be combined (e.g. <code>title,author:"funky~"</code>). Non-partial will win over partial, though.</p>
<p>Also note that these options need to make it through the tokenizing (<a href="#search-options-searching">searching</a>).</p>
<h3 id="indexes-keyformat">Key Format (Format of the indexed Ids)</h3>
<p>By default, the indexed data points to keys that are integers, or differently said, are formatted using <code>to_i</code>.</p>
<p>If you are indexing keys that are strings, use <code>to_sym</code> – a good example are MongoDB <span class="caps">BSON</span> keys, or <span class="caps">UUID</span> keys.</p>
<p>The <code>key_format</code> method lets you define the format:</p>
<pre><code>
Index.new :books do
  key_format :to_sym
end
</code></pre>
<p>The <code>Picky::Sources</code> already set this correctly. However, if you use an <code>#each</code> source that supplies Picky with symbol ids, you should set the <code>key_format</code>.</p>
<h3 id="indexes-results">Identifying in Results</h3>
<p>By default, an index is identified by its <strong>name</strong> in the results. This index is identified by <code>:books</code>:</p>
<pre><code>
Index.new :books do
  # ...
end
</code></pre>
<p>This index is identified by <code>:media</code> in the results:</p>
<pre><code>
Index.new :books do
  # ...
  result_identifier :media
end
</code></pre>
<p>You still refer to it as <code>:books</code> in e.g. Rake tasks, <code>Picky::Indexes[:books].reload</code>. It&#8217;s just for the results.</p>
<h3 id="indexes-indexing">Indexing</h3>
<p>Indexing can be done programmatically. Even when the server is running.</p>
<p>Indexing <strong>all indexes</strong> is done with</p>
<pre><code>Picky::Indexes.index</code></pre>
<p>Indexing a <strong>single index</strong> can be done either with</p>
<pre><code>Picky::Indexes[:index_name].index</code></pre>
<p>or</p>
<pre><code>index_instance.index</code></pre>
<p>Indexing a <strong>single category</strong> of an index can be done either with</p>
<pre><code>Picky::Indexes[:index_name][:category_name].index</code></pre>
<p>or</p>
<pre><code>category_instance.index</code></pre>
<h3 id="indexes-reloading">Reloading</h3>
<p>Reloading your indexes in a running application is possible.</p>
<p>Reloading <strong>all indexes</strong> is done with</p>
<pre><code>Picky::Indexes.reload</code></pre>
<p>Reloading a <strong>single index</strong> can be done either with</p>
<pre><code>Picky::Indexes[:index_name].reload</code></pre>
<p>or</p>
<pre><code>index_instance.reload</code></pre>
<p>Reloading a <strong>single category</strong> of an index can be done either with</p>
<pre><code>Picky::Indexes[:index_name][:category_name].reload</code></pre>
<p>or</p>
<pre><code>category_instance.reload</code></pre>
<h4 id="indexes-reloading-signals">Using signals</h4>
<p>To communicate with your server using signals:</p>
<pre><code>
books_index = Index.new(:books) do
  # ...
end

Signal.trap("USR1") do
  books_index.reindex
end
</code></pre>
<p>This reindexes the books_index when you call</p>
<pre><code>kill -USR1 &lt;server_process_id&gt;</code></pre>
<p>You can refer to the index like so if want to define the trap somewhere else:</p>
<pre><code>
Signal.trap("USR1") do
  Picky::Indexes[:books].reindex
end
</code></pre>
<h3 id="indexes-reindexing">Reindexing</h3>
<p>Reindexing your indexes is just indexing followed by reloading (see above).</p>
<p>Reindexing <strong>all indexes</strong> is done with</p>
<pre><code>Picky::Indexes.reindex</code></pre>
<p>Reindexing a <strong>single index</strong> can be done either with</p>
<pre><code>Picky::Indexes[:index_name].reindex</code></pre>
<p>or</p>
<pre><code>index_instance.reindex</code></pre>
<p>Reindexing a <strong>single category</strong> of an index can be done either with</p>
<pre><code>Picky::Indexes[:index_name][:category_name].reindex</code></pre>
<p>or</p>
<pre><code>category_instance.reindex</code></pre>
<h2 id="search">Search</h2>
<p>Picky offers a <code>Search</code> interface for the indexes. You instantiate it as follows.</p>
<p>Just searching over one index:</p>
<pre><code>
books = Search.new books_index # searching over one index
</code></pre>
<p>Searching over multiple indexes:</p>
<pre><code>
media = Search.new books_index, dvd_index, mp3_index
</code></pre>
<p>Such an instance can then search over all its indexes and returns a <code>Picky::Results</code> object:</p>
<pre><code>
results = media.search "query", # the query text
                            20, # number of ids
                             0  # offset (for pagination)
</code></pre>
<p>Please see the part about <a href="#results">Results</a> to know more about that.</p>
<h3 id="search-options">Options</h3>
<p>You use a block to set search options:</p>
<pre><code>
media = Search.new books_index, dvd_index, mp3_index do
  searching tokenizer_options_or_tokenizer
  boost [:title, :author] =&gt; +2,
        [:author, :title] =&gt; -1
end
</code></pre>
<h4 id="search-options-searching">Searching / Tokenizing</h4>
<p>The <code>searching</code> option describes how <strong>queries</strong> are handled.</p>
<p>Picky by default goes through the following list, in order:</p>
<ol>
	<li><strong>substitutes_characters_with</strong>: A character substituter that responds to <code>#substitute(text) #=&gt; substituted text</code></li>
	<li><strong>removes_characters</strong>: Regexp of characters to remove.</li>
	<li><strong>stopwords</strong>: Regexp of stopwords to remove.</li>
	<li><strong>splits_text_on</strong>: Regexp on where to split the query text, including category qualifiers.</li>
	<li><strong>removes_characters_after_splitting</strong>: Regexp on which characters to remove after the splitting.</li>
	<li><strong>normalizes_words</strong>: [[/matching_regexp/, &#8216;replace match \1&#8217;]]</li>
	<li><strong>rejects_token_if</strong>: lambda { |gets_token| gets_token == :hello }</li>
	<li><strong>case_sensitive</strong>: true or false, false is default.</li>
	<li><strong>max_words</strong>: How many words will be passed into the core engine. Default: Infinity.</li>
</ol>
<p>You pass the above options into</p>
<pre><code>
Search.new *indexes do
  searching options_hash
end
</code></pre>
<p>Or, if you want it to be valid for <strong>all</strong> searches, you can define it outside of the search definition:</p>
<pre><code>
searching options_hash

Search.new *indexes do
  # ...
end
</code></pre>
<p>This only works in the sinatra server if you extend the Sinatra app with <code>Picky::Sinatra</code>, like so:</p>
<pre><code>
class MySearch &lt; Sinatra::Application

  extend Picky::Sinatra

  searching options_hash

  # ...

end
</code></pre>
<p>You can provide your own tokenizer:</p>
<pre><code>
Index.new :books do
  indexing MyTokenizer.new
end
</code></pre>
<p>The tokenizer needs to respond to the method <code>#tokenize(text)</code>, returning a <code>Picky::Query::Tokens</code> object. If you have an array of tokens, e.g. <code>[:my, :nice, :tokens]</code>,<br />
you can pass it into <code>Picky::Query::Tokens.process(my_tokens)</code> to get the tokens and return these.</p>
<p><code>rake 'try[text,some_index,some_category]'</code> (<code>some_index</code>, <code>some_category</code> optional) tells you how a given text is indexed.</p>
<p>It should be rather performance efficient if you want your search engine to be fast.</p>
<h4 id="search-options-boost">Boost</h4>
<p>The <code>boost</code> option defines what combinations to boost.</p>
<p>This is unlike boosting in most other search engines, where you can only boost a given field. I&#8217;ve found it much more useful to boost combinations.</p>
<p>Say, you have an index of addresses. The usual case is that someone is looking for a street and a number. So if Picky encounters that combination (in that order), it should move these results to a more prominent spot.<br />
But if it thinks it&#8217;s a street number, followed by a street, it is probably wrong, since usually you search for &#8220;Road 10&#8221;, instead of &#8220;10 Road&#8221; (assuming this is the case where you come from).</p>
<p>So let&#8217;s boost <code>street, streetnumber</code>, while at the same time deboost <code>streetnumber, street</code>:</p>
<pre><code>
addresses = Search.new address_index do
  boost [:street, :streetnumber] =&gt; +2,
        [:streetnumber, :street] =&gt; -1
end
</code></pre>
<h4 id="search-options-ignore">Ignore Categories</h4>
<p>There&#8217;s a <a href="http://florianhanke.com/blog/2011/09/01/picky-case-study-location-based-ads.html">full blog post</a> devoted to this topic.</p>
<p>In short, the <code>ignore :category_name</code> option makes Picky throw away any result combinations that have the named category in it.</p>
<p>If Picky finds the tokens &#8220;florian hanke&#8221; in both <code>:first_name, :last_name</code> and <code>:last_name, :last_name</code>, and we&#8217;ve instructed it to ignore <code>first_name</code>,</p>
<pre><code>
names = Search.new name_index do
  ignore :first_name
end
</code></pre>
<p>then it will throw away the solutions for <code>:first_name, :last_name</code> and only use <code>:last_name, :last_name</code>.</p>
<h4 id="search-options-unassigned">Ignore Unassigned Tokens</h4>
<p>There&#8217;s a <a href="http://florianhanke.com/blog/2011/09/05/picky-ignoring-unassigned-tokens.html">full blog post</a> devoted to this topic.</p>
<p>In short, the <code>ignore_unassigned_tokens true/false</code> option makes Picky be very lenient with your queries. Usually, if one of the search words is not found, say in a query &#8220;aston martin cockadoodledoo&#8221;, Picky will return an empty result set, because &#8220;cockadoodledoo&#8221; is not in any index, in a car search, for example.</p>
<p>By ignoring the &#8220;cockadoodledoo&#8221; that can&#8217;t be assigned sensibly, you will still get results.</p>
<p>This could be used in a search for advertisements that are shown next to the results.</p>
<p>If you&#8217;ve defined an ads search like so:</p>
<pre><code>
ads_search = Search.new cars_index do
  ignore_unassigned_tokens true
end
</code></pre>
<p>then even if Picky does not find anything for &#8220;aston martin cockadoodledoo&#8221;, it will find an ad, simply ignoring the unassigned token.</p>
<h4 id="search-options-maxallocations">Maximum Allocations<br />
<div class="tags">performance</div></h4>
<p>The <code>max_allocations(integer)</code> option cuts off calculation of allocations.</p>
<p>What does this mean? Say you have code like:</p>
<pre><code>
phone_search = Search.new phonebook do
  max_allocations 1
end
</code></pre>
<p>And someone searches for &#8220;peter thomas&#8221;.</p>
<p>Picky then generates all possible allocations and sorts them.</p>
<p>It might get</p>
<ul>
	<li>[first_name, last_name]</li>
	<li>[last_name, first_name]</li>
	<li>[first_name, first_name]</li>
	<li>etc.</li>
</ul>
<p>with the first allocation being the most probable one.</p>
<p>So, with <code>max_allocations 1</code> it will only use the topmost one and throw away all the others.</p>
<p>It will only go through the first one and calculate only results for that one. This can be used to speed up Picky in case of exploding amounts of allocations.</p>
<h4 id="search-options-terminateearly">Early Termination<br />
<div class="tags">performance</div></h4>
<p>The <code>terminate_early(integer)</code> or <code>terminate_early(with_extra_allocations: integer)</code> option stops Picky from calculate all ids of all allocations.</p>
<p>However, this will also return a wrong total.</p>
<p>So, important note: Only use when you don&#8217;t display a total.</p>
<p>Examples:</p>
<p>Stop as soon as you have calculated enough ids for the allocation.</p>
<pre><code>
phone_search = Search.new phonebook do
  terminate_early # The default uses 0.
end
</code></pre>
<p>Stop as soon as you have calculated enough ids for the allocation, and then calculate 3 allocations more (for example, to show to the user).</p>
<pre><code>
phone_search = Search.new phonebook do
  terminate_early 3
end
</code></pre>
<p>There&#8217;s also a hash form to be more explicit. So the next coder knows what it does. (However, us cool Picky hackers <em>know</em> ;) )</p>
<pre><code>
phone_search = Search.new phonebook do
  terminate_early with_extra_allocations: 5
end
</code></pre>
<p>This option speeds up Picky if you don&#8217;t need a correct total.</p>
<h2 id="results">Results</h2>
<p>Results are returned by the <code>Search</code> instance.</p>
<pre><code>
books = Search.new books_index do
  searching splits_text_on: /[\s,]/
  boost [:title, :author] =&gt; +2
end

results = books.search "test"

p results         # Returns results in log form.
p results.to_hash # Returns results as a hash.
p results.to_json # Returns results as JSON.
</code></pre>
<h3 id="results-logging">Logging</h3>
<p>Picky results can be logged wherever you want.</p>
<p>A Picky Sinatra server logs whatever to wherever you want:</p>
<pre><code>
MyLogger = Logger.new "log/search.log"

# ...

get '/books' do
  results = books.search "test"
  MyLogger.info results
  results.to_json
end
</code></pre>
<p>or set it up in separate files for different environments:</p>
<pre><code>
require "logging/#{PICKY_ENVIRONMENT}"
</code></pre>
<p>A Picky classic server logs to the logger defined with the <code>Picky.logger=</code> writer.</p>
<p>Set it up in a separate <code>logging.rb</code> file (or directly in the <code>app/application.rb</code> file).</p>
<pre><code>
  Picky.logger = Logger.new("log/search.log")
</code></pre>
<p>and the Picky classic server will log the results into it, if it is defined.</p>
<p>Why in a separate file? So that you can have different logging for different environments.</p>
<p>More power to you.</p>
<h3 id="results-sorting">Sorting</h3>
<p>Picky results are always <strong>sorted in the order of the data provided</strong> by the data source.</p>
<p>So if you need different sort orders you have to define two indexes.</p>
<p>Why? This was a conscious design decision on my part. Usually, we do not need multiple sortings in a search application (I reckon around 95% of the cases). However, if you need it, you can.</p>
<h3>Thanks!</h3>
<p>Thanks to whoever made the <a href="http://www.sinatrarb.com/intro">Sinatra <span class="caps">README</span> page</a> for the inspiration.</p>
</div>
</div>
    <div class='license'>
      Logos and all images are
      <a href='http://creativecommons.org/licenses/by/1.0/'>CC Attribution</a>
      licensed to Florian Hanke.
    </div>
    <div class='footer'></div>
    <script type='text/javascript'>
      //<![CDATA[
        var picky = document.getElementsByClassName('picky')[0];
        var footer = document.getElementsByClassName('footer')[0];
        
        var position = 0;
        
        var movePicky = function() {
          if (position == -2780) {
            position = 0;
          } else {
            position -= 20;
            setTimeout(movePicky,5);
          }
          picky.style.backgroundPositionY = position + "px";
        }
        
        footer.onclick = function() {
          setTimeout(movePicky,5);
        };
      //]]>
    </script>
  </body>
</html>
